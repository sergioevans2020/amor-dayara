<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Juego Laberinto Kawaii üíñ</title>
<style>
  body {
    margin: 0; padding: 0;
    background: #ffe6f0;
    font-family: 'Quicksand', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    overflow: hidden;
  }
  h1 {
    font-family: 'Great Vibes', cursive;
    color: #b30059;
    margin: 20px 0 10px;
  }
  #game-container {
    position: relative;
    width: 320px;
    height: 320px;
    background: #f7e6f0;
    border: 4px solid #d63384;
    border-radius: 16px;
    box-shadow: 0 4px 10px rgba(214,51,132,0.4);
    overflow: hidden;
  }
  canvas {
    display: block;
    background: #f7e6f0;
    margin: 0 auto;
    image-rendering: pixelated;
  }
  #controls {
    margin-top: 20px;
    display: flex;
    justify-content: center;
    gap: 20px;
  }
  button {
    font-family: 'Quicksand', sans-serif;
    background: #a3d9a5;
    border: none;
    padding: 12px 20px;
    border-radius: 10px;
    color: #2f6627;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.15);
    transition: background-color 0.3s ease;
    user-select: none;
  }
  button:hover {
    background: #8acb89;
  }
  #message {
    margin-top: 20px;
    font-family: 'Great Vibes', cursive;
    color: #b30059;
    font-size: 24px;
    min-height: 50px;
    user-select: none;
    text-align: center;
    padding: 0 10px;
  }
</style>
</head>
<body>
  <h1>Mini Laberinto del Amor üíñ</h1>
  <div id="game-container">
    <canvas id="game" width="320" height="320"></canvas>
  </div>
  <div id="controls">
    <button id="up">‚¨ÜÔ∏è</button>
    <button id="left">‚¨ÖÔ∏è</button>
    <button id="down">‚¨áÔ∏è</button>
    <button id="right">‚û°Ô∏è</button>
  </div>
  <div id="message"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const tileSize = 40; // 8x8 grid = 320px canvas
  const rows = 8;
  const cols = 8;
  const visionRadius = 2; // how many tiles around player are visible

  // Maze legend:
  // 0 = path
  // 1 = wall
  // 2 = easy stage marker
  // 3 = intermediate stage marker
  // 4 = goal chest

  // Maze layout - design a simple path with walls, markers, and goal
  // Must be 8x8
  const maze = [
    [0,1,1,1,1,1,1,1],
    [0,0,0,0,1,0,0,4],
    [1,1,1,0,1,0,1,1],
    [2,0,1,0,0,0,1,1],
    [1,0,1,1,1,0,1,1],
    [1,0,0,0,3,0,0,1],
    [1,1,1,0,1,1,0,1],
    [1,1,1,0,0,0,0,1],
  ];

  // Player position start (row, col)
  let player = {row: 0, col: 0};

  // Messages for stages
  const stageMessages = {
    2: '¬°Etapa F√°cil! Sigue as√≠, mi amor üíñ',
    3: '¬°Etapa Intermedia! Eres incre√≠ble, sigue adelante üåü',
  };

  // Draw functions
  function drawTile(x, y, type) {
    const px = x * tileSize;
    const py = y * tileSize;

    switch(type) {
      case 0: // path
        ctx.fillStyle = '#fff0f6';
        ctx.fillRect(px, py, tileSize, tileSize);
        break;
      case 1: // wall
        ctx.fillStyle = '#d63384';
        ctx.fillRect(px, py, tileSize, tileSize);
        break;
      case 2: // easy stage
        ctx.fillStyle = '#d0f0c0';
        ctx.fillRect(px, py, tileSize, tileSize);
        // draw heart icon small
        drawHeart(px + tileSize/2, py + tileSize/2, 12, '#66bb6a');
        break;
      case 3: // intermediate stage
        ctx.fillStyle = '#fddede';
        ctx.fillRect(px, py, tileSize, tileSize);
        drawHeart(px + tileSize/2, py + tileSize/2, 12, '#f06292');
        break;
      case 4: // goal chest
        ctx.fillStyle = '#f7f0b0';
        ctx.fillRect(px, py, tileSize, tileSize);
        drawChest(px + tileSize/2, py + tileSize/2);
        break;
    }

    // tile border
    ctx.strokeStyle = '#b30059';
    ctx.lineWidth = 2;
    ctx.strokeRect(px, py, tileSize, tileSize);
  }

  function drawHeart(cx, cy, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(cx, cy + size/4);
    ctx.bezierCurveTo(cx, cy, cx - size/2, cy, cx - size/2, cy + size/4);
    ctx.bezierCurveTo(cx - size/2, cy + size/2, cx, cy + size*0.75, cx, cy + size);
    ctx.bezierCurveTo(cx, cy + size*0.75, cx + size/2, cy + size/2, cx + size/2, cy + size/4);
    ctx.bezierCurveTo(cx + size/2, cy, cx, cy, cx, cy + size/4);
    ctx.closePath();
    ctx.fill();
  }

  function drawChest(cx, cy) {
    // simple chest icon with a heart
    // base
    ctx.fillStyle = '#a67c00';
    ctx.fillRect(cx - 15, cy - 10, 30, 20);
    // lid
    ctx.fillStyle = '#c7a300';
    ctx.fillRect(cx - 15, cy - 18, 30, 10);
    // lock
    ctx.fillStyle = '#7a5c00';
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fill();
    // heart on chest
    drawHeart(cx, cy + 5, 10, '#d63384');
  }

  // Draw avatar (heart kawaii with eyes and feet)
  function drawAvatar(cx, cy) {
    // Heart body
    drawHeart(cx, cy - 5, 20, '#e91e63');

    // Eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(cx - 6, cy - 15, 4, 6, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + 6, cy - 15, 4, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(cx - 6, cy - 15, 2, 3, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + 6, cy - 15, 2, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Feet (small hearts rotated)
    ctx.save();
    ctx.translate(cx - 8, cy + 12);
    ctx.rotate(45 * Math.PI / 180);
    drawHeart(0, 0, 8, '#d63384');
    ctx.restore();

    ctx.save();
    ctx.translate(cx + 8, cy + 12);
    ctx.rotate(-45 * Math.PI / 180);
    drawHeart(0, 0, 8, '#d63384');
    ctx.restore();
  }

  // Clear canvas
  function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Draw the maze visible only around player (fog of war effect)
  function drawMaze() {
    clear();

    for(let r = 0; r < rows; r++) {
      for(let c = 0; c < cols; c++) {
        const dist = Math.abs(r - player.row) + Math.abs(c - player.col);
        if(dist <= visionRadius) {
          drawTile(c, r, maze[r][c]);
        } else {
          // Draw fog tile
          ctx.fillStyle = '#f7e6f0';
          ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);
          ctx.strokeStyle = '#f7e6f0';
          ctx.strokeRect(c * tileSize, r * tileSize, tileSize, tileSize);
        }
      }
    }

    // Draw avatar centered in player's tile
    const cx = player.col * tileSize + tileSize / 2;
    const cy = player.row * tileSize + tileSize / 2;
    drawAvatar(cx, cy);
  }

  // Message area
  const messageDiv = document.getElementById('message');

  // Check for stage messages
  function checkStage() {
    const cell = maze[player.row][player.col];
    if(stageMessages[cell]) {
      messageDiv.textContent = stageMessages[cell];
    } else {
      messageDiv.textContent = '';
    }
  }

  // Check for goal and interaction
  let reachedGoal = false;
  function checkGoal() {
    if(maze[player.row][player.col] === 4) {
      reachedGoal = true;
      messageDiv.textContent = '¬°Llegaste al cofre! Haz click en √©l para abrir üíñ';
    } else if(!stageMessages[maze[player.row][player.col]]) {
      messageDiv.textContent = '';
    }
  }

  // Handle clicks to open the chest only when on goal tile
  canvas.addEventListener('click', (e) => {
    if(reachedGoal) {
      const cx = player.col * tileSize + tileSize / 2;
      const cy = player.row * tileSize + tileSize / 2;
      // Calculate click pos relative to canvas
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // Simple hit test on chest area
      if(x >= cx - 15 && x <= cx + 15 && y >= cy - 18 && y <= cy + 10) {
        messageDiv.textContent = '¬°Felicidades, mi amor! üíñ Eres la reina de mi coraz√≥n.';
      }
    }
  });

  // Movement function with collision check
  function movePlayer(dRow, dCol) {
    const newRow = player.row + dRow;
    const newCol = player.col + dCol;

    if(newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols) return;
    if(maze[newRow][newCol] === 1) return; // muro

    player.row = newRow;
    player.col = newCol;

    checkStage();
    checkGoal();
    drawMaze();
  }

  // Button controls
  document.getElementById('up').addEventListener('click', () => movePlayer(-1, 0));
  document.getElementById('down').addEventListener('click', () => movePlayer(1, 0));
  document.getElementById('left').addEventListener('click', () => movePlayer(0, -1));
  document.getElementById('right').addEventListener('click', () => movePlayer(0, 1));

  // Keyboard controls
  window.addEventListener('keydown', e => {
    switch(e.key) {
      case 'ArrowUp': e.preventDefault(); movePlayer(-1,0); break;
      case 'ArrowDown': e.preventDefault(); movePlayer(1,0); break;
      case 'ArrowLeft': e.preventDefault(); movePlayer(0,-1); break;
      case 'ArrowRight': e.preventDefault(); movePlayer(0,1); break;
    }
  });

  // Initial draw
  drawMaze();
  checkStage();
  checkGoal();

})();
</script>
</body>
</html>
